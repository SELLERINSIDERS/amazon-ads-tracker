---
phase: 01-foundation-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - next.config.ts
  - tsconfig.json
  - tailwind.config.ts
  - postcss.config.mjs
  - app/layout.tsx
  - app/globals.css
  - prisma/schema.prisma
  - lib/prisma.ts
  - lib/session.ts
  - lib/dal.ts
  - .env.example
  - .env.local
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Next.js dev server starts on port 3001"
    - "Prisma can connect to SQLite database"
    - "Session configuration is ready for use"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies"
      contains: "iron-session"
    - path: "prisma/schema.prisma"
      provides: "Database schema"
      contains: "datasource db"
    - path: "lib/prisma.ts"
      provides: "Prisma singleton"
      contains: "globalForPrisma"
    - path: "lib/session.ts"
      provides: "Session configuration"
      contains: "SessionData"
    - path: "lib/dal.ts"
      provides: "Data Access Layer"
      contains: "verifySession"
  key_links:
    - from: "lib/prisma.ts"
      to: "prisma/schema.prisma"
      via: "PrismaClient generation"
      pattern: "PrismaClient"
    - from: "lib/dal.ts"
      to: "lib/session.ts"
      via: "getSession import"
      pattern: "import.*getSession.*from.*session"
---

<objective>
Set up Next.js 14 foundation with Prisma/SQLite database and iron-session configuration.

Purpose: Establish the core infrastructure that all authentication and dashboard features will build upon.
Output: Working Next.js app on port 3001 with database connectivity and session utilities ready.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Next.js application with all dependencies</name>
  <files>
    package.json
    next.config.ts
    tsconfig.json
    tailwind.config.ts
    postcss.config.mjs
    app/layout.tsx
    app/globals.css
    .gitignore
  </files>
  <action>
    1. Initialize Next.js 14 with App Router using create-next-app:
       - Use TypeScript, Tailwind CSS, ESLint
       - Use App Router (not Pages Router)
       - Use src/ directory: NO (keep app/ at root per research structure)

    2. Install authentication and database dependencies:
       ```bash
       npm install iron-session bcrypt zod server-only
       npm install --save-dev @types/bcrypt
       npm install prisma @prisma/client better-sqlite3
       npm install --save-dev @types/better-sqlite3
       ```

    3. Update package.json scripts to use port 3001:
       ```json
       "dev": "next dev -p 3001",
       "start": "next start -p 3001"
       ```

    4. Add postinstall script for Prisma:
       ```json
       "postinstall": "prisma generate"
       ```

    5. Initialize shadcn/ui:
       ```bash
       npx shadcn@latest init -d
       ```
       Use defaults (New York style, Zinc color, CSS variables)

    6. Add shadcn components needed for auth:
       ```bash
       npx shadcn@latest add button input card
       ```

    7. Update .gitignore to include:
       - .env.local
       - prisma/dev.db
       - prisma/dev.db-journal
  </action>
  <verify>
    - `npm run dev` starts server on http://localhost:3001
    - Visit http://localhost:3001 shows Next.js default page
    - No dependency errors in terminal
  </verify>
  <done>Next.js app runs on port 3001 with all dependencies installed and shadcn/ui initialized</done>
</task>

<task type="auto">
  <name>Task 2: Configure Prisma with SQLite and create database schema</name>
  <files>
    prisma/schema.prisma
    lib/prisma.ts
    .env.example
    .env.local
  </files>
  <action>
    1. Initialize Prisma with SQLite:
       ```bash
       npx prisma init --datasource-provider sqlite
       ```

    2. Update prisma/schema.prisma with initial models:
       ```prisma
       generator client {
         provider = "prisma-client-js"
       }

       datasource db {
         provider = "sqlite"
         url      = env("DATABASE_URL")
       }

       // User model for future extensibility (not used in simple password auth)
       model User {
         id        String   @id @default(cuid())
         email     String   @unique
         name      String?
         createdAt DateTime @default(now())
         updatedAt DateTime @updatedAt
       }

       // Session tracking (optional, for audit purposes)
       model Session {
         id        String   @id @default(cuid())
         userId    String
         createdAt DateTime @default(now())
         expiresAt DateTime
       }
       ```

    3. Create lib/prisma.ts with singleton pattern (from research Pattern 1):
       ```typescript
       import { PrismaClient } from '@prisma/client'

       const globalForPrisma = globalThis as unknown as {
         prisma: PrismaClient | undefined
       }

       export const prisma = globalForPrisma.prisma ?? new PrismaClient()

       if (process.env.NODE_ENV !== 'production') {
         globalForPrisma.prisma = prisma
       }

       export default prisma
       ```
       NOTE: Using standard PrismaClient (not better-sqlite3 adapter) as Prisma's native SQLite support is sufficient and simpler.

    4. Create .env.local with:
       ```
       DATABASE_URL="file:./prisma/dev.db"
       SESSION_SECRET="generate-a-32-char-minimum-secret-here"
       PPC_DASHBOARD_PASSWORD="temporary-dev-password"
       ```

    5. Create .env.example (no secrets, for git):
       ```
       DATABASE_URL="file:./prisma/dev.db"
       SESSION_SECRET=your-secret-key-here-min-32-characters
       PPC_DASHBOARD_PASSWORD=your-dashboard-password
       ```

    6. Run initial migration:
       ```bash
       npx prisma migrate dev --name init
       ```

    7. Generate Prisma client:
       ```bash
       npx prisma generate
       ```
  </action>
  <verify>
    - `npx prisma studio` opens database browser
    - prisma/dev.db file exists
    - lib/prisma.ts has no TypeScript errors
  </verify>
  <done>Prisma configured with SQLite, schema created, singleton pattern implemented</done>
</task>

<task type="auto">
  <name>Task 3: Create session configuration and Data Access Layer</name>
  <files>
    lib/session.ts
    lib/dal.ts
    lib/auth.ts
  </files>
  <action>
    1. Create lib/session.ts with iron-session config (from research Pattern 2):
       ```typescript
       import { SessionOptions } from 'iron-session'
       import { cookies } from 'next/headers'
       import { getIronSession } from 'iron-session'

       export interface SessionData {
         userId?: string
         isLoggedIn: boolean
       }

       export const defaultSession: SessionData = {
         isLoggedIn: false,
       }

       export const sessionOptions: SessionOptions = {
         password: process.env.SESSION_SECRET!,
         cookieName: 'ppc-dashboard-session',
         cookieOptions: {
           httpOnly: true,
           secure: process.env.NODE_ENV === 'production',
           sameSite: 'lax',
           maxAge: 60 * 60 * 24 * 7, // 7 days
         },
       }

       export async function getSession() {
         const cookieStore = await cookies()
         return getIronSession<SessionData>(cookieStore, sessionOptions)
       }
       ```

    2. Create lib/dal.ts with Data Access Layer (from research Pattern 3):
       ```typescript
       import 'server-only'
       import { cache } from 'react'
       import { redirect } from 'next/navigation'
       import { getSession } from './session'

       export const verifySession = cache(async () => {
         const session = await getSession()

         if (!session.isLoggedIn) {
           redirect('/login')
         }

         return { isAuth: true, userId: session.userId }
       })

       export const getSessionSafe = cache(async () => {
         const session = await getSession()
         return {
           isLoggedIn: session.isLoggedIn,
           userId: session.userId,
         }
       })
       ```

    3. Create lib/auth.ts with password utilities (from research - bcrypt in separate file for Node.js runtime):
       ```typescript
       import 'server-only'
       import bcrypt from 'bcrypt'

       const SALT_ROUNDS = 10

       export async function hashPassword(password: string): Promise<string> {
         return bcrypt.hash(password, SALT_ROUNDS)
       }

       export async function comparePassword(
         password: string,
         hashedPassword: string
       ): Promise<boolean> {
         return bcrypt.compare(password, hashedPassword)
       }

       // For simple password auth, we compare against env var directly
       // (no hashing needed since env vars are already secure)
       export function validateDashboardPassword(password: string): boolean {
         return password === process.env.PPC_DASHBOARD_PASSWORD
       }
       ```

    4. Install server-only package if not already:
       ```bash
       npm install server-only
       ```
  </action>
  <verify>
    - lib/session.ts compiles without TypeScript errors
    - lib/dal.ts compiles without TypeScript errors
    - lib/auth.ts compiles without TypeScript errors
    - `npm run build` succeeds (no import errors)
  </verify>
  <done>Session configuration, DAL, and auth utilities are ready for use by login/middleware</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run dev` starts without errors on port 3001
2. `npx prisma studio` shows empty User and Session tables
3. All lib/*.ts files compile without errors
4. `.env.local` exists with all required variables
5. `.env.example` exists and is safe to commit
</verification>

<success_criteria>
- Next.js 14 app running on port 3001
- Prisma connected to SQLite with schema migrated
- Session configuration ready for iron-session
- Data Access Layer ready for protected routes
- All dependencies installed and working
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-01-SUMMARY.md`
</output>
